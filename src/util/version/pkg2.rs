const VERIFY_KEY: u32 = 0x1A2B3C4D;

pub struct VersionGen {
    pub hash1: u32,
    pub hash2: u32,
    pub(crate) v2_results: Vec<u32>,
    current_idx: usize,
}

impl VersionGen {
    pub fn new(hash1: u32, hash2: u32) -> Self {
        Self {
            hash1,
            hash2,
            v2_results: Vec::new(),
            current_idx: 0,
        }
    }
    pub fn verify_hash_version_v1(&mut self, hash: u32) -> bool {
        let lt = self.hash1.rotate_left(7) ^ hash;
        lt == self.hash2
    }
    pub fn verify_hash_version_v2(&mut self, hash: u32) -> bool {
        let rotate_base = self.hash1 ^ (hash.wrapping_add(VERIFY_KEY));
        let lt = rotate_base.rotate_left((hash & 0x1f) as u32);
        (lt ^ hash) == self.hash2
    }

    pub fn calc_hash_version_v1(&mut self) -> u32 {
        self.hash1.rotate_left(7) ^ self.hash2
    }
    pub fn calc_hash_version_v2(&mut self) -> Vec<u32> {
        let mut results: Vec<u32> = Vec::new();
        let mut carries = [0; 33];
        let mut lhs_bits = [0; 32];
        for s_candidate in 0..32 {
            carries.fill(0);
            lhs_bits.fill(0);
            self.backtrack(0, 0, s_candidate, &mut carries, &mut lhs_bits, &mut results);
        }
        results
    }
    // ported code from WzComparerR2(C#) and it's generated by google AI
    // @link https://github.com/Kagamia/WzComparerR2/blob/2b23c99325569815c9abbca10d91a6baefbf1b86/WzComparerR2.WzLib/Wz_Header.cs#L263
    pub fn backtrack(
        &mut self,
        bit_idx: u32,
        v_hash: u32,
        s: u32,
        carries: &mut [u32],
        lhs_bits: &mut [u32],
        results: &mut Vec<u32>,
    ) {
        if bit_idx == 32 {
            if ((v_hash & 0x1f) == s) && self.verify_hash_version_v2(v_hash) {
                results.push(v_hash);
            }
            return;
        }

        let start = if bit_idx < 5 { (s >> bit_idx) & 1 } else { 0 };
        let end = if bit_idx < 5 { (s >> bit_idx) & 1 } else { 1 };

        for v_bit in start..=end {
            let prev_lhs_idx = (bit_idx.wrapping_sub(s).wrapping_add(32)) & 0x1f;
            if prev_lhs_idx < bit_idx {
                let v_xor_h2 = v_bit ^ ((self.hash2 >> bit_idx) & 1);
                if v_xor_h2 != lhs_bits[prev_lhs_idx as usize] {
                    continue;
                }
            }

            let sum = v_bit + ((VERIFY_KEY >> bit_idx) & 1) + carries[bit_idx as usize];
            let current_lhs_bit = (sum ^ (self.hash1 >> bit_idx)) & 1;

            let future_v_idx = (bit_idx.wrapping_add(s)) & 0x1f;
            if future_v_idx <= bit_idx {
                let known_v_bit = (v_hash >> future_v_idx) & 1;
                let target_v_xor_h2 = known_v_bit ^ ((self.hash2 >> future_v_idx) & 1);
                if current_lhs_bit != target_v_xor_h2 {
                    continue;
                }
            } else if future_v_idx < 5 {
                let known_v_bit = (s >> future_v_idx) & 1;
                let target_v_xor_h2 = known_v_bit ^ ((self.hash2 >> future_v_idx) & 1);
                if current_lhs_bit != target_v_xor_h2 {
                    continue;
                }
            }

            lhs_bits[bit_idx as usize] = current_lhs_bit;
            carries[bit_idx as usize + 1] = sum >> 1;

            self.backtrack(
                bit_idx + 1,
                v_hash | (v_bit << bit_idx),
                s,
                carries,
                lhs_bits,
                results,
            );
        }
    }
}

impl Iterator for VersionGen {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // index is 0, return v1 hash
        if self.current_idx == 0 {
            let result = Some(self.calc_hash_version_v1());
            self.current_idx += 1;
            return result;
        }
        // calculate v2 hashes if not calculated yet
        if self.v2_results.len() == 0 {
            self.v2_results = self.calc_hash_version_v2();
        }
        let result = self.v2_results.get(self.current_idx - 1).cloned();
        self.current_idx += 1;
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const HASH1: u32 = 0x0000abcd;
    const HASH2: u32 = 0x12340000;

    #[test]
    fn test_pkg2_version_gen_v1() {
        let mut version_gen = VersionGen::new(HASH1, HASH2);
        let v = version_gen.next().unwrap();
        assert!(version_gen.verify_hash_version_v1(v));
    }

    #[test]
    fn test_pkg2_version_gen_v2() {
        let mut version_gen = VersionGen::new(HASH1, HASH2);
        let _v1_hash = version_gen.next().unwrap();

        let v = version_gen.next().unwrap();

        assert!(version_gen.v2_results.len() > 0);
        assert!(version_gen.verify_hash_version_v2(v));
    }
}
